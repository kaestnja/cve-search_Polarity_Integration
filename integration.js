'use strict';

let request = require('request');
let config = require('./config/config');
let async = require('async');
let fs = require('fs');
let Logger;
let url = require('url');

let requestOptions = {};
const MAX_PARALLEL_LOOKUPS = 10;
/**
 *
 * @param entities
 * @param options
 * @param cb
 */
function doLookup(entities, options, cb) {
    let lookupResults = [];
    let tasks = [];

    Logger.trace(entities);

    entities.forEach(entity => {
        //do the lookup
        let url = options.url;
        if(!url.endsWith('/')){
            url += '/';
        }

        requestOptions.uri = url + 'cve/' + entity.value;
        requestOptions.method = 'GET';
        requestOptions.json = true;

        Logger.debug({url: requestOptions.uri}, 'Lookup URL');

        tasks.push(function (done) {
            request(requestOptions, function (error, res, body) {
                if(error){
                    Logger.error({error:error, res: res, body:body}, 'HTTP Request Error');
                    done(error);
                    return;
                }

                if (res.statusCode === 200) {
                    done(null, {
                        entity: entity,
                        body: body
                    });
                }else{
                    done(body);
                }
            });
        });
    });

    async.parallelLimit(tasks, MAX_PARALLEL_LOOKUPS, (err, results) => {
        if (err) {
            cb(err);
            return;
        }

        results.forEach(result => {
            if (result.body === null) {
                lookupResults.push({
                    entity: result.entity,
                    data: null
                });
            } else {
                lookupResults.push({
                    entity: result.entity,
                    data: {
                        summary: [result.entity.value],
                        details: result.body
                    }
                });
            }
        });

        cb(null, lookupResults);
    });
}

function startup(logger) {
    Logger = logger;

    if (typeof config.request.cert === 'string' && config.request.cert.length > 0) {
        requestOptions.cert = fs.readFileSync(config.request.cert);
    }

    if (typeof config.request.key === 'string' && config.request.key.length > 0) {
        requestOptions.key = fs.readFileSync(config.request.key);
    }

    if (typeof config.request.passphrase === 'string' && config.request.passphrase.length > 0) {
        requestOptions.passphrase = config.request.passphrase;
    }

    if (typeof config.request.ca === 'string' && config.request.ca.length > 0) {
        requestOptions.ca = fs.readFileSync(config.request.ca);
    }

    if (typeof config.request.proxy === 'string' && config.request.proxy.length > 0) {
        requestOptions.proxy = config.request.proxy;
    }
}

function validateOptions(userOptions, cb) {
    let errors = [];
    if (typeof userOptions.url.value !== 'string' ||
        (typeof userOptions.url.value === 'string' && userOptions.url.value.length === 0)) {
        errors.push({
            key: 'url',
            message: 'You must provide a server URL'
        })
    }

    cb(null, errors);
}

module.exports = {
    doLookup: doLookup,
    startup: startup,
    validateOptions: validateOptions
};